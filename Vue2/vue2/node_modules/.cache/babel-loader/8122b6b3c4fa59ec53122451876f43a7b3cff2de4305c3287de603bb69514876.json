{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forwardAsync = forwardAsync;\nexports.isAsync = void 0;\nexports.isThenable = isThenable;\nexports.maybeAsync = maybeAsync;\nexports.waitFor = exports.onFirstPause = void 0;\nfunction _gensync() {\n  const data = require(\"gensync\");\n  _gensync = function () {\n    return data;\n  };\n  return data;\n}\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) {\n  try {\n    var i = n[a](c),\n      u = i.value;\n  } catch (n) {\n    return void e(n);\n  }\n  i.done ? t(u) : Promise.resolve(u).then(r, o);\n}\nfunction _asyncToGenerator(n) {\n  return function () {\n    var t = this,\n      e = arguments;\n    return new Promise(function (r, o) {\n      var a = n.apply(t, e);\n      function _next(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n      }\n      function _throw(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n      }\n      _next(void 0);\n    });\n  };\n}\nconst runGenerator = _gensync()(function* (item) {\n  return yield* item;\n});\nconst isAsync = exports.isAsync = _gensync()({\n  sync: () => false,\n  errback: cb => cb(null, true)\n});\nfunction maybeAsync(fn, message) {\n  return _gensync()({\n    sync(...args) {\n      const result = fn.apply(this, args);\n      if (isThenable(result)) throw new Error(message);\n      return result;\n    },\n    async(...args) {\n      return Promise.resolve(fn.apply(this, args));\n    }\n  });\n}\nconst withKind = _gensync()({\n  sync: cb => cb(\"sync\"),\n  async: function () {\n    var _ref = _asyncToGenerator(function* (cb) {\n      return cb(\"async\");\n    });\n    return function async(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }()\n});\nfunction forwardAsync(action, cb) {\n  const g = _gensync()(action);\n  return withKind(kind => {\n    const adapted = g[kind];\n    return cb(adapted);\n  });\n}\nconst onFirstPause = exports.onFirstPause = _gensync()({\n  name: \"onFirstPause\",\n  arity: 2,\n  sync: function (item) {\n    return runGenerator.sync(item);\n  },\n  errback: function (item, firstPause, cb) {\n    let completed = false;\n    runGenerator.errback(item, (err, value) => {\n      completed = true;\n      cb(err, value);\n    });\n    if (!completed) {\n      firstPause();\n    }\n  }\n});\nconst waitFor = exports.waitFor = _gensync()({\n  sync: x => x,\n  async: function () {\n    var _ref2 = _asyncToGenerator(function* (x) {\n      return x;\n    });\n    return function async(_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }()\n});\nfunction isThenable(val) {\n  return !!val && (typeof val === \"object\" || typeof val === \"function\") && !!val.then && typeof val.then === \"function\";\n}\n0 && 0;","map":{"version":3,"names":["_gensync","data","require","asyncGeneratorStep","n","t","e","r","o","a","c","i","u","value","done","Promise","resolve","then","_asyncToGenerator","arguments","apply","_next","_throw","runGenerator","item","isAsync","exports","sync","errback","cb","maybeAsync","fn","message","args","result","isThenable","Error","async","withKind","_ref","_x","forwardAsync","action","g","kind","adapted","onFirstPause","name","arity","firstPause","completed","err","waitFor","x","_ref2","_x2","val"],"sources":["../../src/gensync-utils/async.ts"],"sourcesContent":["import gensync, { type Gensync, type Handler, type Callback } from \"gensync\";\n\ntype MaybePromise<T> = T | Promise<T>;\n\nconst runGenerator: {\n  sync<Return>(gen: Handler<Return>): Return;\n  async<Return>(gen: Handler<Return>): Promise<Return>;\n  errback<Return>(gen: Handler<Return>, cb: Callback<Return>): void;\n} = gensync(function* (item: Handler<any>): Handler<any> {\n  return yield* item;\n});\n\n// This Gensync returns true if the current execution context is\n// asynchronous, otherwise it returns false.\nexport const isAsync = gensync({\n  sync: () => false,\n  errback: cb => cb(null, true),\n});\n\n// This function wraps any functions (which could be either synchronous or\n// asynchronous) with a Gensync. If the wrapped function returns a promise\n// but the current execution context is synchronous, it will throw the\n// provided error.\n// This is used to handle user-provided functions which could be asynchronous.\nexport function maybeAsync<Args extends unknown[], Return>(\n  fn: (...args: Args) => Return,\n  message: string,\n): Gensync<Args, Return> {\n  return gensync({\n    sync(...args) {\n      const result = fn.apply(this, args);\n      if (isThenable(result)) throw new Error(message);\n      return result;\n    },\n    async(...args) {\n      return Promise.resolve(fn.apply(this, args));\n    },\n  });\n}\n\nconst withKind = gensync({\n  sync: cb => cb(\"sync\"),\n  async: async cb => cb(\"async\"),\n}) as <T>(cb: (kind: \"sync\" | \"async\") => MaybePromise<T>) => Handler<T>;\n\n// This function wraps a generator (or a Gensync) into another function which,\n// when called, will run the provided generator in a sync or async way, depending\n// on the execution context where this forwardAsync function is called.\n// This is useful, for example, when passing a callback to a function which isn't\n// aware of gensync, but it only knows about synchronous and asynchronous functions.\n// An example is cache.using, which being exposed to the user must be as simple as\n// possible:\n//     yield* forwardAsync(gensyncFn, wrappedFn =>\n//       cache.using(x => {\n//         // Here we don't know about gensync. wrappedFn is a\n//         // normal sync or async function\n//         return wrappedFn(x);\n//       })\n//     )\nexport function forwardAsync<Args extends unknown[], Return>(\n  action: (...args: Args) => Handler<Return>,\n  cb: (\n    adapted: (...args: Args) => MaybePromise<Return>,\n  ) => MaybePromise<Return>,\n): Handler<Return> {\n  const g = gensync(action);\n  return withKind(kind => {\n    const adapted = g[kind];\n    return cb(adapted);\n  });\n}\n\n// If the given generator is executed asynchronously, the first time that it\n// is paused (i.e. When it yields a gensync generator which can't be run\n// synchronously), call the \"firstPause\" callback.\nexport const onFirstPause = gensync<\n  [gen: Handler<unknown>, firstPause: () => void],\n  unknown\n>({\n  name: \"onFirstPause\",\n  arity: 2,\n  sync: function (item) {\n    return runGenerator.sync(item);\n  },\n  errback: function (item, firstPause, cb) {\n    let completed = false;\n\n    runGenerator.errback(item, (err, value) => {\n      completed = true;\n      cb(err, value);\n    });\n\n    if (!completed) {\n      firstPause();\n    }\n  },\n}) as <T>(gen: Handler<T>, firstPause: () => void) => Handler<T>;\n\n// Wait for the given promise to be resolved\nexport const waitFor = gensync({\n  sync: x => x,\n  async: async x => x,\n}) as <T>(p: T | Promise<T>) => Handler<T>;\n\nexport function isThenable<T = any>(val: any): val is PromiseLike<T> {\n  return (\n    !!val &&\n    (typeof val === \"object\" || typeof val === \"function\") &&\n    !!val.then &&\n    typeof val.then === \"function\"\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}